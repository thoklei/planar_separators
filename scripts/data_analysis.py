"""
This script analyses the experimental data.
More specifically:
    1. Plots the relative separator sizes as a bar chart, across all instances
    2. Plots
"""
import pandas as pd
import argparse
import utils
from utils import analyze_separator_size, analyze_instance_performance


def main(path):
    """
    Calls the different analysis methods.

    :param path: path to csv-file generated by experiments
    """

    # read csv file
    df = pd.read_csv(path, sep=r'\s*,\s*', encoding='utf-8')

    # Which core algorithm yields the smallest relative separators?
    instances = df['instance'].unique()
    analyze_separator_size(df, "rel_sepsize_core", utils.core_algorithms, instances)

    # Okay, looks like Har-Peled is the best core separator.

    # Does this change if post-processing is applied?
    analyze_separator_size(df, "rel_sepsize_simple_post", utils.simple_postprocessors, instances)

    # Looks like all separators benefit from NE the most, but this did not really change anything.

    # What about combinations of postproccesors?
    analyze_separator_size(df, "rel_sepsize_complex_post", utils.complex_postprocessors, instances)

    # Looks like multiple postprocessors are not really better than just the NodeExpulsor.

    # Now, let's check the performance of all algorithms + NE per instance in one huge plot.
    analyze_instance_performance(df, "per_instance", instances, utils.core_algorithms)

    # Ok looks like Har-Peled is the best algorithm everywhere, except for maybe diameter graphs.


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Data analysis and plotting.')
    parser.add_argument('--path', type=str, help='Path to data file')
    args = parser.parse_args()

    main(args.path)
