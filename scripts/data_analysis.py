"""
This script analyses the experimental data.
More specifically:
    1. Plots the relative separator sizes as a bar chart, across all instances
    2. Plots
"""
import pandas as pd
import argparse
import utils
import os
from utils import analyze_separator_size, analyze_instance_performance, analyze_separator_speed, \
    analyze_separator_balance


def main(path, target):
    """
    Calls the different analysis methods.

    :param path: path to csv-file generated by experiments
    :param target: path to folder to contain results
    """

    # read csv file
    df = pd.read_csv(path, sep=r'\s*,\s*', encoding='utf-8', engine='python')

    # Which core algorithm yields the smallest relative separators?
    instances = df['instance'].unique()
    # analyze_separator_size(df, "rel_sepsize_core", utils.core_algorithms, instances, target)
    #
    # # Okay, looks like Har-Peled is the best core separator.
    #
    # # Does this change if post-processing is applied?
    # analyze_separator_size(df, "rel_sepsize_simple_post", utils.simple_postprocessors, instances, target)
    #
    # # Looks like all separators benefit from NE the most, but this did not really change anything.
    #
    # # What about combinations of postproccesors?
    # analyze_separator_size(df, "rel_sepsize_complex_post", utils.all_algs_and_post, instances, target)
    #
    # # Looks like multiple postprocessors are not really better than just the NodeExpulsor.
    #
    # # Now, let's check the performance of all algorithms + NE per instance in one huge plot.
    # analyze_instance_performance(df, "per_instance", instances, utils.core_algorithms, target)

    # Ok looks like Har-Peled is the best algorithm everywhere, except for maybe diameter graphs.

    # Next, let's check runtime:
    algorithms = df['algorithm'].unique()
    algorithms = [alg for alg in algorithms if alg in utils.core_algorithms]
    analyze_separator_speed(df, "rel_speed_core", algorithms, instances, target)

    # Also analyse the average balance between components:
    # analyze_separator_balance(df, "avg_balance", utils.dmd_only, instances, target)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Data analysis and plotting.')
    parser.add_argument('--path', type=str, help='Path to data file')
    parser.add_argument('--target', type=str, help='Path to folder with plots')
    args = parser.parse_args()

    if not os.path.exists(args.target):
        os.mkdir(args.target)
    main(args.path, args.target)
