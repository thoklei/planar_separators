"""
Analyses if triangulating first when running LT works better.
"""
import pandas as pd
import argparse

from utils import analyze_separator_size, analyze_instance_performance, filter_instances


def main(path):
    """
    Compares regular LT vs TRI = LT with triangulation first.

    :param path: path to csv-file generated by experiments (LT_compare.csv)
    """

    # read csv file
    df = pd.read_csv(path, sep=r'\s*,\s*', encoding='utf-8')

    # which algorithm yields the smallest relative separators across all instances?
    comp_alg = ['LT', 'TRI']
    instances = df['instance'].unique()
    analyze_separator_size(df, "comp/rel_sepsize_core", comp_alg, instances)

    # Okay, looks like regular LT is the best core separator.

    # Does this change if post-processing is applied?
    comp_simple = ['LT', 'LT_NE', 'LT_DMD', 'TRI', 'TRI_NE', 'TRI_DMD']
    analyze_separator_size(df, "comp/rel_sepsize_simple_post", comp_simple, instances)

    # This did not really change anything, which was expected.

    # Now, let's check the performance of the two algorithms per instance in one huge plot.
    instances = df['instance'].unique()
    analyze_instance_performance(df, "comp/per_instance", instances, comp_alg)

    # Looks like LT is much better, except for random instances.

    # Let's do that again, but only for random instances
    random_instances = filter_instances(instances, ["random"])
    analyze_instance_performance(df, "comp/per_instance_random", random_instances, comp_alg)

    # Final verdict: LT is much better, except for random instances.


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Data analysis and plotting.')
    parser.add_argument('--path', type=str, help='Path to data file')
    args = parser.parse_args()

    main(args.path)
